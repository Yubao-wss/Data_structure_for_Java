### 数据结构：堆（完全二叉树-二叉堆）

优先级队列：以堆为底层结构，按照优先级大小先入先出

经典问题：如何在O（nlog)时间内找到100w个元素中的前100个元素？

#### 堆：完全二叉树

只有完全二叉树可以用数组表示（顺序储存）

堆中任何一个节点的值不大于其父节点的值（最大堆 或 大顶堆）

堆中层数越高，值一定越大？不一定，但在最大堆中根节点的值一定是堆的最大值。



堆用数组储存时，下标为0储存第一个元素

若当前节点的下标为x，

则左孩子下标 2x +1

右孩子下标 2x +2

其父节点的数组下标（x-1)/2



#### 如何添加元素

add(E e)：默认在数组末尾添加元素，此时添加元素，可能会破坏堆的结构，需要进行元素上浮

siftUp元素上浮



#### 取出（删除）堆的最大值

将最大值删除：

​	-将堆顶元素与堆的最后一个元素交换

​	（在完全二叉树中判断一个节点为叶子节点：左孩子的节点下标大于数组长度）

​	-下沉交换后的堆顶元素

#### replace:将堆的堆顶元素替换为新元素

​	-extractMax()、add()

​	-siftDown

#### heapify:将任意数组整理成堆

​	-add

​	-从最后一个非叶子节点开始siftDown，直到根节点为止



#### 堆排序

在原数组直接进行堆排序

1.任意数组 -> 完全二叉树

2.Heapify(从最后一个非叶子节点开始) -> 完全二叉树 -> 堆

3.不断从当前堆的堆顶 -> 数组末尾，再将交换后的数组Heapify



#### 优先级队列

内置：java.util.PriorityQueue 是一个基于最小堆的优先级队列

获取N个元素中的前K个元素 < O(nlogn)



获取N个元素中第K大个元素 O(n) = 利用快排的分区思想



前K个高频元素

1.遍历元素集，将具体的key值与其出现频率保存Map中

2.使用优先级队列存储出现频率最高的前K个键值对

3.使用List存储优先级队列中的所有Key

