## 排序算法

### 1.如何衡量一个排序算法的优劣

####  1.1 算法的执行效率

> a.最好、最坏、平均时间复杂度
>
> b.系数、低阶、常数(冒泡、插入),由于n的大小并不是足够大
>
> c.比较或交换次数。 

#### 1.2 算法的内存消耗:通过空间复杂度来衡量

原地排序:特指空间复杂度为O(1)的排序算法

#### 1.3 排序算法的稳定性

稳定性 : 若待排序的集合中存在值相等的元素，经过排序之后，相等元素之间原有的顺序是否改变.若未改变，则称此排序为稳定性排序。

 

排序前: 2,9,3,5,8,3,4

排序后: 2,3,3,4,5,8,9

 

订单:金额、下单时间

300 17:00:00      300 18:00:00

301 14:00:00   -> 300 17:00:00  

300 18:00:00      301 14:00:00

 

需求:如何按照金额排序后的数据，时间也是有序的?相同金额的订单按照时间顺序排序。

 

解决:先按照时间顺序排序一次，再按照金额进行稳定性的排序。

### 2.排序分类

#### 内部排序:

排序过程无需借助外部存储器(如磁盘)，所有排序操作均在内存中完成。默认说的排序都是内部排序

#### 外部排序:

若参与排序的元素过多，数据量过大，内存放不下,需要借助外部存储器来进行排序，

如桶排序。

 

无论是内部排序还是外部排序，最终数据的排序一定在内存中进行。

内部排序按照排序思路分为以下四类

#### 2.1插入排序法:

> 直接插入排序
>
> 希尔排序
>

#### 2.2选择排序:

> 选择排序
>
> 堆排序
>

#### 2.3交换排序:

> 冒泡排序
>
> 快速排序
>

#### 2.4归并排序

 

3大O(n^2)时间复杂度排序

冒泡、插入、选择

### 3.冒泡排序

冒泡排序只会操作相邻的两个元素。每次对相邻的两个元素做大小比较，看是否满足大小关系。

一次冒泡至少会让一个元素移动到最终位置(冒泡)

 

4,5,6,1,1,2,3 要求按照升序排序

 

优化:设置标志位，若在某次循环结束后发现并没有元素交换，认为数据集已经有序，停止循环。

 

算法的执行效率

最好情况

数据集本身就是一个有序集合,O(n)

 

最坏情况

数据集完全逆序,O(n^2)

 

平均情况O(n^2)

 

算法的内存消耗:O(1)，无需开辟新的空间，仅仅是原有数据做交换。

冒泡排序是一个原地排序算法。

 

算法的稳定性

冒泡排序由于相邻元素发生大小关系变换才会交换次序，所以当两个元素大小相等时，

并不会改变其相对顺序。

### 4.插入排序:

基于有序集合插入思想的排序算法

3,3,4,5,2,1

 

直接插入排序:基于有序数组元素内容的插入得来

核心思想:将待排序的数据分为两个区间，已排序区间与待排序区间。

算法刚开始时，已排序空间有一个元素，在待排序空间中选择第一个元素与已排序空间的最后一个元素比较，若比已排序的最大元素大直接放入已排序空间最后一个位置，否则需要找到合适位置后进行插入。

 

时间复杂度

最好O(n)

最坏O(n^2)

 

空间复杂度

原地排序算法

 

稳定性

稳定性算法

### 5.希尔排序：

优化:原先找到插入位置后，元素是一个一个向后搬移，损耗较大。

能否在搬移元素时多走几步，即一次多搬移几个元素。

 

原先:一次走一步

一次多走几步

 

空间复杂度:O(1)

稳定性:稳定

 

选择排序:

时间复杂度:O(n^2)

空间复杂度:O(1)

稳定性:不稳定排序

eg:5 8 5 2 9

 

插入还是选择?

在相同数据集下，推荐使用插入排序，由于选择排序的不稳定性

 

在近乎有序的数据下，直接插排、选择排序、希尔排序、折半插排

### 6.归并排序:

时间复杂度：O(nlogn)

 

归并与快排都应用分治思想,如何在O(n)内寻找一个无序数组的第K大元素？

 

分治思想:将一个大的问题分为若干个足够小的问题，当所有小问题解决后，将结果合并起来就是整个问题的求解。

 

所有使用分治思想解决的问题均可利用递归的技巧完美解决。

 

稳定性:取决于合并函数写法,arr[i] <= arr[j]

 

时间复杂度:O(nlogn)

最好、最坏、 平均都一样

 

空间复杂度:O(n),临时数组在合并后空间会释放,由于不是一个原地排序算法，因此使用较少。

### 7.快速排序:

20世纪最重要的算法之一,基于分治思想 O(nlogn),1s轻松完成百万数量级的排序

 

算法思路:从待排序的数组中选取任意一个元素[l..r],称为分区点(基准值)开始遍历过程，每当发现比基准值小的元素就放在基准值左边，每当发现>=基准值元素就放在基准值右边。

 

当结束一次遍历时，基准值元素一定在最终位置。

 

分区函数能否原地排序?O(1)

 

问题:当待排序元素近乎有序时，若选取的基准值恰好为最大值，此时分层退化成O(n),此时快排的时间复杂度退化为O(n^2) 最坏情况

最好情况:每次分区点的选择都恰好在中间位置，O(nlogn)

平均O(nlogn)

 

空间:O(1),原地排序

 

稳定性:不稳定算法(若基准值为最后一个元素,5 4 3 2 6 1 5)

 

扩展问题:如何在O(n)时间内找到一个无序数组的第K大元素?

 

分区点:

5 1 2 3 6 8 7 

 

1 2 3 5 6 8 7

 

5 1 2 3 4 6 8 7

 

1 2 3 4 5 6 7 8

 

若k = 5

若array[i+1] = ，array[i] 就是第k大元素

 

若k > i+1 , 

 

n/2 + n/4 + n/8 +... + 1

#### 快排优化:

1.当待排序的集合近乎有序时，由于默认选择的第一个元素作为基准值，会导致基准值划分的两个子数组严重不均衡，此时分层下来的结果近乎于n层，此时快排退化为复杂度为O(n^2)排序算法

解决:随机选取一个元素作为基准值，来降低每次都选到最小或最大值的概率

 

2.当待排序集合包含大量重复元素时，由于与基准值相等的元素个数过多，导致数组长度不均衡，此时分层下来的结果近乎n层，快排退化为O(n^2)

#### 二路快排:

将大于和小于v的元素放在数组的两端,i索引不断向后扫描，当i的元素小于v时，i++;j索引不断向前扫描，当j的元素大于v时，j--;当i碰到一个>=v的元素以及j碰到一个<=v的元素，交换i与j的元素,i++,j--

快排:

分治:任意选取一个基准值，将所有比基准值放左边，比基准值大的放右边。一次过程下来，基准值到达最终位置。按照基准值左边与右边待排序数组重复上述过程

 

原地排序:默认选取第一个元素

 

优化1:随机选取一个基准值来避免分组造成的左右两个区间严重不均衡状态,造成分层趋向于O(n)层导致快排退化为O(n^2)

 

优化2:当待排序的数组中重复元素过多导致分组造成的左右两个区间严重不均衡状态,造成分层趋向于O(n)层导致快排退化为O(n^2)

双路快排:将重复元素交换位置来实现左右两个数组都有元素，避免分组不均衡的情况发生。

#### 优化3:三路快排

...

#### 归并排序优化:

1.当元素个数比较小时，调用直接插入排序.

2.当左边数组最大元素都小于右边数组最小元素，说明整个数组有序，直接结束排序。  

​      

```java
// 合并
        if (array[mid] >= array[mid+1]) {
            merge(array,low,mid,high);
        }
```

### 8.线性排序:O(n)

桶排序:外部排序

如何在O(n)时间内按照年龄大小给100万个用户排序

 

将元素均匀分桶后进行快排

 

计数排序(桶排特殊情况)

基数排序:每位排序都采用稳定性排序

 

如何在O(n)时间内按照用户手机号给100w用户排序

 

排序:

 

稳定性:冒泡 直接插入 折半插入

 

非稳定:希尔 归并 选择 快排

 

O(n^2) : 冒泡 直接插入 折半插入 选择

O(n^3/2) : 希尔 

O(nlogn) : 归并 快排(随机化 二路 三路)

